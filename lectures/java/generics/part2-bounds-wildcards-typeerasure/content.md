# Bounds, Wildcards, Type Erasure


-
-
## What we'll cover
<p class="fragment fade-up">Bounds</p>
<p class="fragment fade-up">Wildcards</p>
<p class="fragment fade-up">Type Erasure</p>
<p class="fragment fade-up">Polymorphism and Bridge Methods</p>


-
-
## Bounds
```Java
public static <T extends Comparable> T min(T[] a){...}
```
When `extending` T must always be a subtype of it's bounding type.  
REMEMBER: if B extends A, that does NOT mean that T&lt;B> extends T&lt;A>
-
-
## Wildcards
Unbounded Wildcards are used when you don't care about the type.
```Java
public static boolean isEven(List<?> list) {
  return (list.size() % 2 == 0)
}
```
Bounded Wildcards, however, let you care somewhat about the type  
`? extends Something` is typically when you are reading from something generic.  Means any subclass of `Something`.  
`? super Something` is typically when you are writing to something generic.  Means any superclass of `Something`.  
-
-
You can also capture wildcards by passing the variable to another function that doesn't have a wildcard.  Though, this is rarely used (or allowed), since the compiler needs to be certain that the wildcard represents a single type.
-
-
## Type Erasure
At compile time for generics, the type parameters are erased and replaced with their upper bounds.  And, if there isn't one, then it replaces them with Object.
```Java
class Box<T> {
  public T contents;
  public T getContents {return contents;}
}
```
becomes
```Java
class Box {
  public Object contents;
  public Object getContents {return contents;}
}
```
-
-
and
```Java
class Box<T extends Comparable> {
  public T contents;
  public T getContents {return contents;}
}
```
becomes
```Java
class Box{
  public Comparable contents;
  public Comparable getContents {return contents;}
}
```
Also, if `Box` extended multiple things, the compiler would merely make everything the first type, and then cast to the latter ones when necessary.
-
-
## Polymorphism and Bridge Methods
Java synthesizes bridge methods for us so we can have generics and polymorphism.
-
-
```Java
public class Node<T> {

    public T data;

    public Node(T data) { this.data = data; }

    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}
public class MyNode extends Node<Integer> {
    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```
-
-
After type erasure (note `setData` methods):
```Java
public class Node {
    public Object data;
    public Node(Object data) { this.data = data; }
    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}
public class MyNode extends Node {

    public MyNode(Integer data) { super(data); }
	 //Does not override Node.setData() !!!
    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```
-
-
Compiler creates a new "Bridge method" to fix this problem
```Java
class MyNode extends Node {

    // Bridge method generated by the compiler
    //
    public void setData(Object data) {
        setData((Integer) data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    // ...
}
```

-
-
# Reflection
You can, in fact, leverage reflection to find out about an Object's generic past.  This is all at runtime, though.  So, in all reality, you can see what's happening and where Objects came from, but know that as far as the compiler is concerned, they don't really matter.  Like, they've functinonally been erased, but there is still a record.
